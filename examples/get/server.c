//******************************************************************
//
// Copyright 2016 NORC at the University of Chicago
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <getopt.h>
#include <signal.h>
#include <pthread.h>

#include "logger.h"
#include "payload_logging.h"

#include "server.h"
#include "temperature.h"
#include "utils.h"

#define TAG "GET server"

pthread_t pt_work;

/* Platform Descriptor: OCPlatformInfo
 * This structure describes the platform properties. All non-Null properties will be
 * included in a platform discovery request. */
OCPlatformInfo platform_info =
  {
    .platformID			= "Iochibity-GET-Test",
    .manufacturerName		= "Iochibity",
    .manufacturerUrl		= "example.org",
    .modelNumber		= "1.0",
    .dateOfManufacture		= "01-01-2016",
    .platformVersion		= "0.1.0",
    .operatingSystemVersion	= "11.5",
    .hardwareVersion		= "0.1.0",
    .firmwareVersion		= "0.1.0",
    .supportUrl			= "example.org/support",
    .systemTime			= "2015-05-15T11.04"
  };

static struct rsvp_temperature my_temperature_rsvp = { .t     = RSC_T_TEMPERATURE,
						.iface = RSC_IF_TEMPERATURE,
						.uri   = RSC_URI_TEMPERATURE,
						.props = { .state = 0 },
						.dispatch_request = temperature_request_dispatcher };

/* Device Descriptor: OCDeviceInfo
 * This structure is expected as input for device properties.
 * device name is mandatory and expected from the application.
 * device id of type UUID will be generated by the stack. */
OCDeviceInfo device_info =
  {
    .deviceName = "minDeviceName",
    /* OCStringLL *types; */
    .specVersion = "minDeviceSpecVersion" /* device specification version */
    // .dataModelVersions = "minDeviceModelVersion"
  };

/* const char *deviceUUID = "myDeviceUUID"; */
/* const char *version = "myVersion"; */

OCEntityHandlerResult
default_request_dispatcher (OCEntityHandlerFlag flag,
			    OCEntityHandlerRequest *oic_request, /* just like HttpRequest */
			    char *uri,
			    void *cb /*callbackParam*/)
{
    OC_UNUSED(flag);
    OC_UNUSED(oic_request);
    OC_UNUSED(uri);
    OC_UNUSED(cb);
    OCEntityHandlerResult ehResult = OC_EH_OK;
    /* OCEntityHandlerResponse response; */
    return ehResult;
}

#define SAMPLE_MAX_NUM_OBSERVATIONS     8
#define SAMPLE_MAX_NUM_POST_INSTANCE  2

observers_t interestedObservers[SAMPLE_MAX_NUM_OBSERVATIONS];

pthread_t threadId_observe;
/* pthread_t threadId_presence; */

/* #ifdef WITH_PRESENCE */
/* #define numPresenceResources (2) */
/* #endif */

int gQuitFlag = 0;

/* SIGINT handler: set gQuitFlag to 1 for graceful termination */
void handleSigInt(int signum)
{
    if (signum == SIGINT)
    {
	/* if (OCStop() != OC_STACK_OK) { */
	/*     printf("OCStack process error\n"); */
	/* } else { */
	/*     printf("foo\n"); */
	/* } */
        gQuitFlag = 1;
    }
}

/* thread routine - service client requests */
void *troutine_work(void *arg)
{
    OC_UNUSED(arg);
    printf("Entering server work thread...\n");

    while (!gQuitFlag) {
	if (OCProcess() != OC_STACK_OK) {
	    printf("OCStack process error\n");
	}
    }
    printf("Exiting server work thread...\n");
    /* we're the only thread left, pthread_exit(NULL) would kill us,
       but not the process. */
    exit(0);
}

static void PrintUsage()
{
    printf("Usage : ocserver -o <0|1>\n");
    printf("-o 0 : Notify all observers\n");
    printf("-o 1 : Notify list of observers\n");
}

/****************************************************************
 *  MAIN
 *  1. initialize rmgr (stack)
 *  2. register platform info
 *  3. register device info
 *  4. register service routine for default rsvp
 *  5. register Resource Service Provider for each resource
 *  6. spawn work thread
 *  7. exit main thread, leaving process (and work thread) running
 ****************************************************************/
int main(int argc, char* argv[])
{
    /* pthread_t pt_main = pthread_self(); */

    /* int opt = 0; */

    /* while ((opt = getopt(argc, argv, "o:s:p:d:u:w:r:j:")) != -1) { */
    /*   switch(opt) { */
    /*   case 'o': */
    /* 	g_observe_notify_type = atoi(optarg); */
    /* 	break; */
    /*   default: */
    /* 	PrintUsage(); */
    /* 	return -1; */
    /*   } */
    /* } */

    /* if ((g_observe_notify_type != 0) && (g_observe_notify_type != 1)) { */
    /*     PrintUsage(); */
    /*     return -1; */
    /* } */

    OCStackResult op_result;

    /* 1. initialize */
    op_result = OCInit(NULL, 0, OC_CLIENT_SERVER);
    if (op_result != OC_STACK_OK) {
        printf("OCStack init error\n");
        return 0;
    }

    /* 2. register platform info */
    op_result = OCSetPlatformInfo(platform_info);
    if (op_result == OC_STACK_OK) {
        OIC_LOG(INFO, TAG, "Platform Registration succeeded\n");
	OCPlatformInfo* pi;
	if ( OCGetPlatformInfo(&pi) == OC_STACK_OK ) {
	    OIC_LOG(INFO, TAG, "OCGetPlatformInfo success\n");
	    print_platform_info(pi);
	} else {
	    OIC_LOG(ERROR, TAG, "OCGetPlatformInfo failure\n");
	    exit (EXIT_FAILURE);
	}
    } else {
        OIC_LOG(ERROR, TAG, "Platform Registration failed!\n");
        exit (EXIT_FAILURE);
    }

    /* 3. register default device info */
    OCResourcePayloadAddStringLL(&device_info.types, "oic.wk.d");
    op_result = OCSetDeviceInfo(device_info);
    if (op_result != OC_STACK_OK) {
        printf("Device Registration failed!\n");
        exit (EXIT_FAILURE);
    }

    /* 4. register service routine for default rsvp */
    op_result = OCSetDefaultDeviceEntityHandler(default_request_dispatcher, NULL);
    if (op_result != OC_STACK_OK) {
        printf("Default rsvp service routine registration failed!\n");
        exit (EXIT_FAILURE);
    }

    /* 5. register rsvps */
    op_result = rmgr_register_temperature_rsvp (&my_temperature_rsvp);
    if (op_result != OC_STACK_OK) {
      printf("TEMPERATURE resource service provider registration failed!\n");
      exit (EXIT_FAILURE);
    } else {
      printf("TEMPERATURE resource service provider registration succeeded!\n");
    }

    /* register async quit signal handler */
    signal(SIGINT, handleSigInt);

    pthread_create (&pt_work, NULL, troutine_work, (void *)NULL);

    /* main thread has nothing to do. by calling pthread_exit it exits
       but the process continues, so any spawned threads do too. */
    pthread_exit(NULL);
}

