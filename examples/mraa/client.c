//******************************************************************
//
// Copyright 2016 NORC at the University of Chicago
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#include <pthread.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <getopt.h>
#include <signal.h>
#include <pthread.h>

#include "ocstack.h"
#include "logger.h"
#include "ocpayload.h"
#include "payload_logging.h"
#include "oic_malloc.h"
#include "oic_string.h"

#include "client.h"
#include "button.h"
#include "led.h"

#define TAG "minclient"

/* call routine in utils.c to get the result in string format. */
const char *result_to_str(OCStackResult result);

#define DEFAULT_CONTEXT_VALUE 0x99

static int UnicastDiscovery = 0;

pthread_t ui_thread;

/* %s will be replaced by IP address */
static const char *RSC_URI_RESOURCES = "%s/oic/res";
static const char *RSC_URI_PLATFORM  = "%s/oic/p";
static const char *PLATFORM_DISCOVERY_QUERY = "%s/oic/p";

static const char *RSC_URI_DEVICE    = "%s/oic/d";

static char discoveryAddr[100];

/* Platform Descriptor: OCPlatformInfo
 * This structure describes the platform properties. All non-Null properties will be
 * included in a platform discovery request. */
OCPlatformInfo platform_info =
  {
    .platformID			= "clientPlatformID",
    .manufacturerName		= "clientName",
    .manufacturerUrl		= "clientManufacturerUrl",
    .modelNumber		= "clientModelNumber",
    .dateOfManufacture		= "clientDateOfManufacture",
    .platformVersion		= "clientPlatformVersion",
    .operatingSystemVersion	= "clientOS",
    .hardwareVersion		= "clientHardwareVersion",
    .firmwareVersion		= "clientFirmwareVersion",
    .supportUrl			= "clientSupportUrl",
    .systemTime			= "2015-05-15T11.04"
  };

/* Device Descriptor: OCDeviceInfo
 * This structure is expected as input for device properties.
 * device name is mandatory and expected from the application.
 * device id of type UUID will be generated by the stack. */
OCDeviceInfo device_info =
  {
    .deviceName = "clientDeviceName",
    /* OCStringLL *types; */
    .specVersion = "clientDeviceSpecVersion", /* device specification version */
    .dataModelVersion = "clientDeviceModleVersion"
  };

/* const char *deviceUUID = "myDeviceUUID"; */
/* const char *version = "myVersion"; */

OCEntityHandlerResult
default_request_dispatcher (OCEntityHandlerFlag flag,
			    OCEntityHandlerRequest *oic_request, /* just like HttpRequest */
			    char *uri,
			    void *cb /*callbackParam*/)
{
    OCEntityHandlerResult ehResult = OC_EH_OK;
    OCEntityHandlerResponse response;
    return ehResult;
}

#define SAMPLE_MAX_NUM_OBSERVATIONS     8
#define SAMPLE_MAX_NUM_POST_INSTANCE  2

observers_t interestedObservers[SAMPLE_MAX_NUM_OBSERVATIONS];

pthread_t threadId_observe;
/* pthread_t threadId_presence; */

static bool observeThreadStarted = false;

/* #ifdef WITH_PRESENCE */
/* #define numPresenceResources (2) */
/* #endif */

int gQuitFlag = 0;
int waiting   = 0;

struct ResourceNode *resourceList;

/* SIGINT handler: set gQuitFlag to 1 for graceful termination */
void handleSigInt(int signum)
{
    if (signum == SIGINT)
    {
        gQuitFlag = 1;
    }
}

static void PrintUsage()
{
    printf("Usage : ocserver -o <0|1>\n");
    printf("-o 0 : Notify all observers\n");
    printf("-o 1 : Notify list of observers\n");
}

/* **************************************************************** */
void queryResource()
{
    /* switch(TestCase) */
    /* { */
    /*     case TEST_DISCOVER_REQ: */
    /*         break; */
    /*     case TEST_NON_CON_OP: */
    /*         InitGetRequest(OC_LOW_QOS); */
    /*         InitPutRequest(OC_LOW_QOS); */
    /*         InitPostRequest(OC_LOW_QOS); */
    /*         break; */
    /*     case TEST_CON_OP: */
    /*         InitGetRequest(OC_HIGH_QOS); */
    /*         InitPutRequest(OC_HIGH_QOS); */
    /*         InitPostRequest(OC_HIGH_QOS); */
    /*         break; */
    /*     default: */
    /*         PrintUsage(); */
    /*         break; */
    /* } */
}

void print_resource_list()
{
    struct ResourceNode * iter;
    iter = resourceList;
    OIC_LOG(INFO, TAG, "Resource List: ");
    while(iter)
    {
        OIC_LOG(INFO, TAG, "*****************************************************");
        OIC_LOG_V(INFO, TAG, "sid = %s",iter->sid);
        OIC_LOG_V(INFO, TAG, "uri = %s", iter->uri);
        OIC_LOG_V(INFO, TAG, "ip = %s", iter->endpoint.addr);
        OIC_LOG_V(INFO, TAG, "port = %d", iter->endpoint.port);
        switch (iter->endpoint.adapter)
        {
            case OC_ADAPTER_IP:
                OIC_LOG(INFO, TAG, "connType = Default (IPv4)");
                break;
            case OC_ADAPTER_GATT_BTLE:
                OIC_LOG(INFO, TAG, "connType = BLE");
                break;
            case OC_ADAPTER_RFCOMM_BTEDR:
                OIC_LOG(INFO, TAG, "connType = BT");
                break;
            default:
                OIC_LOG(INFO, TAG, "connType = Invalid connType");
                break;
        }
        OIC_LOG(INFO, TAG, "*****************************************************");
        iter = iter->next;
    }
}

/* This function searches for the resource(sid:uri) in the ResourceList.
 * If the Resource is found in the list then it returns 0 else insert
 * the resource to front of the list and returns 1.
 */
int insert_resource(const char * sid, /* server id */
		    char const * uri, /* resource uri */
		    const OCDevAddr device_address)
{
    struct ResourceNode * iter = resourceList;
    char * sid_cpy =  OICStrdup(sid);
    char * uri_cpy = OICStrdup(uri);

    //Checking if the resource(sid:uri) is new
    while(iter)
    {
        if((strcmp(iter->sid, sid) == 0) && (strcmp(iter->uri, uri) == 0))
        {
            OICFree(sid_cpy);
            OICFree(uri_cpy);
            return 0;
        }
        else
        {
            iter = iter->next;
        }
    }

    //Creating new ResourceNode
    if((iter = (struct ResourceNode *) OICMalloc(sizeof(struct ResourceNode))))
    {
        iter->sid = sid_cpy;
        iter->uri = uri_cpy;
        iter->endpoint = device_address;
        iter->next = NULL;
    }
    else
    {
        OIC_LOG(ERROR, TAG, "Memory not allocated to ResourceNode");
        OICFree(sid_cpy);
        OICFree(uri_cpy);
        return -1;
    }

    //Adding new ResourceNode to front of the ResourceList
    if(!resourceList)
    {
        resourceList = iter;
    }
    else
    {
        iter->next = resourceList;
        resourceList = iter;
    }
    return 1;
}

/* collectUniqueResource - occlientbasicopts.cpp */
void resource_payload_to_resource_ll(const char              *server_id,
				     OCDevAddr                device_address,
				     const OCResourcePayload *resource_data)
{
  /* OCResourcePayload is a linked list of OCResourcePayload nodes */

    // Including the NUL terminator, length of UUID string of the form:
    //   "a62389f7-afde-00b6-cd3e-12b97d2fcf09"
#define UUID_LENGTH 37

    char server_uuid[UUID_LENGTH];

    int ret = snprintf(server_uuid, UUID_LENGTH,
		       "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
		       server_id[0], server_id[1], server_id[2], server_id[3],
		       server_id[4], server_id[5], server_id[6], server_id[7],
		       server_id[8], server_id[9], server_id[10], server_id[11],
		       server_id[12], server_id[13], server_id[14], server_id[15]
		       );

    if (ret != UUID_LENGTH - 1) {
        OIC_LOG_V(ERROR, TAG, "Could not convert the Server ID %s to UUID", server_id);
	/* exit? */
    }

    OIC_LOG_V(INFO, TAG, "Server ID: %s", server_id);
    OIC_LOG_V(INFO, TAG, "Server UUID: %s", server_uuid);


    while(resource_data) {
      if(insert_resource(server_uuid, resource_data->uri, device_address) == 1) {
	    OIC_LOG_V(INFO,TAG,"%s%s%s%s\n", server_uuid, ":", resource_data->uri, " newly discovered");
	    print_resource_list();
	    queryResource();
	} else {
	    OIC_LOG_V(INFO,TAG,"%s%s%s%s\n", server_uuid, ":", resource_data->uri, " already discovered");
	}
        resource_data = resource_data->next;
    }
}

/* ****************************************************************
 *     Service Routines
 ****************************************************************/
OCStackApplicationResult svc_platform_discovery_response(void* ctx,
							 OCDoHandle handle,
							 OCClientResponse * clientResponse)
{
    if (ctx == (void*) DEFAULT_CONTEXT_VALUE)
    {
        OIC_LOG(INFO, TAG, "Callback Context for Platform DISCOVERY  recd");
    }

    if (clientResponse)
    {
        OIC_LOG(INFO, TAG, ("Discovery Response:"));
        OIC_LOG_PAYLOAD(INFO, clientResponse->payload);
	/* OCPayloadLogPlatform(INFO, (OCPlatformPayload *)clientResponse->payload); */
	/* printf("dev addr: %x\n", clientResponse->devAddr); */
	/* printf("identity: %x\n"); */
	/* printf("sequence nbr: %x\n"); */
	/* printf("resource uri: %s\n", clientResponse->resourceUri); */
	/* printf("vnd hdr options count: %d\n", clientResponse->numRcvdVendorSpecificHeaderOptions); */
    }
    else
    {
        OIC_LOG_V(INFO, TAG, "PlatformDiscoveryReqCB received Null clientResponse");
    }

    waiting = 0;		/* tell ui thread we're done */
    return (UnicastDiscovery) ? OC_STACK_DELETE_TRANSACTION : OC_STACK_KEEP_TRANSACTION;
}

OCStackApplicationResult svc_device_discovery_response(void* ctx,
						       OCDoHandle handle,
						       OCClientResponse * clientResponse)
{
    if (ctx == (void*) DEFAULT_CONTEXT_VALUE)
    {
        OIC_LOG(INFO, TAG, "Callback Context for Device DISCOVER query recvd successfully");
        OIC_LOG_V(INFO, TAG, "Response dev: %s", clientResponse->devAddr.addr);
        OIC_LOG_V(INFO, TAG, "Response port: %d", clientResponse->devAddr.port);
        OIC_LOG_V(INFO, TAG, "Response uri: %s", clientResponse->resourceUri);
    }

    if (clientResponse)
    {
        OIC_LOG(INFO, TAG, ("Discovery Response:"));
        OIC_LOG_PAYLOAD(INFO, clientResponse->payload);
    }
    else
    {
        OIC_LOG_V(INFO, TAG, "PlatformDiscoveryReqCB received Null clientResponse");
    }

    waiting = 0;		/* tell ui thread we're done */
    return (UnicastDiscovery) ? OC_STACK_DELETE_TRANSACTION : OC_STACK_KEEP_TRANSACTION;
}

OCStackApplicationResult svc_resource_discovery_response(void *ctx,
							 OCDoHandle handle,
							 OCClientResponse *clientResponse)
{
    if (ctx == (void*)DEFAULT_CONTEXT_VALUE) {
        OIC_LOG(INFO, TAG, "\n<====Callback Context for RESOURCE DISCOVERY action "
               "received successfully====>");
    } else {
        OIC_LOG(ERROR, TAG, "\n<====Callback Context for DISCOVERY fail====>");
    }

    if (clientResponse) {
        OIC_LOG_V(INFO, TAG,
                "Client Device =====> Discovered @ %s:%d",
                clientResponse->devAddr.addr,
                clientResponse->devAddr.port);
        OIC_LOG_PAYLOAD(INFO, clientResponse->payload);

        /* collectUniqueResource(clientResponse); */
	resource_payload_to_resource_ll(( (OCDiscoveryPayload*)clientResponse->payload)->sid,
					clientResponse->devAddr,
					((OCDiscoveryPayload*)clientResponse->payload)->resources);
    } else {
        OIC_LOG(ERROR, TAG, "<====DISCOVERY Callback fail to receive clientResponse====>\n");
    }

    waiting = 0;		/* tell ui thread we're done */
    return (UnicastDiscovery) ?
           OC_STACK_DELETE_TRANSACTION : OC_STACK_KEEP_TRANSACTION ;
}

const char *get_adapter_label(int adapter)
{
    const char *adapters[8];
    adapters[0] = "DEFAULT";
    adapters[1] = "IP";
    adapters[2] = "BLE";
    adapters[3] = "RFCOMM over BT EDR";
    adapters[4] = "XMPP (Remote Access)";
    adapters[5] = "CoAP/TCP";
    adapters[6] = "NFC";
    adapters[7] = "Invalid adapter";
    switch (adapter)
	{
	case OC_DEFAULT_ADAPTER:
	    return adapters[0];
	    break;
	case OC_ADAPTER_IP:
	    return adapters[1];
	    break;
	case OC_ADAPTER_GATT_BTLE:
	    return adapters[2];
	    break;
	case OC_ADAPTER_RFCOMM_BTEDR:
	    return adapters[3];
	    break;
#ifdef RA_ADAPTER
	case OC_ADAPTER_REMOTE_ACCESS:
	    return adapters[4];
	    break;
#endif
	case OC_ADAPTER_TCP:
	    return adapters[5];
	    break;
	case OC_ADAPTER_NFC:
	    return adapters[6];
	    break;
	default:
	    return adapters[7];
	    break;
	}
}

OCStackApplicationResult
svc_get_response(void* ctx,
		 OCDoHandle handle,
		 OCClientResponse *client_response)
{
    OIC_LOG_V(INFO, TAG, "Servicing GET response from %s (adapter %s) (port %d) %s",
	      client_response->devAddr.addr,
	      get_adapter_label(client_response->devAddr.adapter),
	      client_response->devAddr.port, client_response->resourceUri);
    if (ctx != (void*) DEFAULT_CONTEXT_VALUE) {
	OIC_LOG(ERROR, TAG, "<====Callback Context for GET fail====>");
    }

    if (client_response) {
	OIC_LOG_V(INFO, TAG, "StackResult: %s",  result_to_str(client_response->result));
	OIC_LOG_V(INFO, TAG, "SEQUENCE NUMBER: %d", client_response->sequenceNumber);
	OIC_LOG_PAYLOAD(INFO, client_response->payload);

	if (client_response->numRcvdVendorSpecificHeaderOptions > 0 ) {
	    OIC_LOG (INFO, TAG, "Received vendor specific options");
	    uint8_t i = 0;
	    OCHeaderOption * rcvdOptions = client_response->rcvdVendorSpecificHeaderOptions;
	    for (i = 0; i < client_response->numRcvdVendorSpecificHeaderOptions; i++) {
		if (((OCHeaderOption) rcvdOptions[i]).protocolID == OC_COAP_ID) {
		    OIC_LOG_V(INFO, TAG, "Received option with OC_COAP_ID and ID %u with",
			      ((OCHeaderOption)rcvdOptions[i]).optionID );

		    OIC_LOG_BUFFER(INFO, TAG, ((OCHeaderOption)rcvdOptions[i]).optionData,
				   MAX_HEADER_OPTION_DATA_LENGTH);
		}
	    }
	}
    } else {
	OIC_LOG(ERROR, TAG, "<====GET Callback fail to receive client_response====>\n");
    }
    waiting = 0;
    return OC_STACK_DELETE_TRANSACTION;
}

/* ****************************************************************
 *        ACTIONS
 **************************************************************** */

int discover_platform(OCQualityOfService qos)
{
    OIC_LOG_V(INFO, TAG, "\n\nExecuting %s", __func__);

    OCStackResult ret;
    OCCallbackData cbData;
    char szQueryUri[64] = { 0 };

    snprintf(szQueryUri, sizeof (szQueryUri) - 1, PLATFORM_DISCOVERY_QUERY, discoveryAddr);

    cbData.cb = svc_device_discovery_response;
    cbData.context = (void*)DEFAULT_CONTEXT_VALUE;
    cbData.cd = NULL;

    ret = OCDoResource(NULL, OC_REST_DISCOVER, szQueryUri, NULL, 0, CT_DEFAULT,
                       (qos == OC_HIGH_QOS) ? OC_HIGH_QOS : OC_LOW_QOS,
                       &cbData, NULL, 0);
    if (ret != OC_STACK_OK)
    {
        OIC_LOG(ERROR, TAG, "OCStack device error");
    }

    return ret;
}

int discover_device(OCQualityOfService qos)
{
    OIC_LOG_V(INFO, TAG, "\n\nExecuting %s", __func__);

    OCStackResult ret;
    OCCallbackData cbData;
    char szQueryUri[100] = { 0 };

    snprintf(szQueryUri, sizeof (szQueryUri) - 1, RSC_URI_DEVICE, discoveryAddr);

    cbData.cb = svc_device_discovery_response;
    cbData.context = (void*)DEFAULT_CONTEXT_VALUE;
    cbData.cd = NULL;

    ret = OCDoResource(NULL, OC_REST_DISCOVER, szQueryUri, NULL, 0, CT_DEFAULT,
                       (qos == OC_HIGH_QOS) ? OC_HIGH_QOS : OC_LOW_QOS,
                       &cbData, NULL, 0);
    if (ret != OC_STACK_OK)
    {
        OIC_LOG(ERROR, TAG, "OCStack device error");
    }

    return ret;
}

int discover_resources(OCQualityOfService qos)
{
    OCStackResult ret;
    OCCallbackData cbData;
    char queryUri[200];
    char ipaddr[100] = { '\0' };

    /* if (UnicastDiscovery) */
    /* { */
    /*     OIC_LOG(INFO, TAG, "Enter IP address (with optional port) of the Server hosting resource\n"); */
    /*     OIC_LOG(INFO, TAG, "IPv4: 192.168.0.15:45454\n"); */
    /*     OIC_LOG(INFO, TAG, "IPv6: [fe80::20c:29ff:fe1b:9c5]:45454\n"); */

    /*     if (fgets(ipaddr, sizeof (ipaddr), stdin)) */
    /*     { */
    /*         StripNewLineChar(ipaddr); //Strip newline char from ipaddr */
    /*     } */
    /*     else */
    /*     { */
    /*         OIC_LOG(ERROR, TAG, "!! Bad input for IP address. !!"); */
    /*         return OC_STACK_INVALID_PARAM; */
    /*     } */
    /* } */

    snprintf(queryUri, sizeof (queryUri), RSC_URI_RESOURCES, ipaddr);

    printf("Query uri: %s\n", queryUri);

    cbData.cb = svc_resource_discovery_response;
    cbData.context = (void*)DEFAULT_CONTEXT_VALUE;
    cbData.cd = NULL;

    ret = OCDoResource(NULL,
		       OC_REST_DISCOVER,
		       queryUri,
		       0, 0, CT_DEFAULT, OC_LOW_QOS,
		       &cbData,
		       NULL, 0);
    if (ret != OC_STACK_OK)
    {
        OIC_LOG(ERROR, TAG, "OCStack resource error");
    }
    return ret;
}

OCPayload* set_put_payload()
{
    OCRepPayload* payload = OCRepPayloadCreate();

    if(!payload) {
        printf("Failed to create put payload object");
        exit(1);
    }

    OCRepPayloadSetPropInt(payload, "power", 15);
    OCRepPayloadSetPropBool(payload, "state", true);

    return (OCPayload*) payload;
}

OCStackResult act_on_resource(const char *query,
			      OCMethod method,
			      const OCDevAddr *dest,
			      OCQualityOfService qos,
			      OCClientResponseHandler cb,
			      OCHeaderOption * options, uint8_t numOptions)
{
    OCStackResult ret;
    OCCallbackData cbData;

    cbData.cb = cb;
    cbData.context = (void*)DEFAULT_CONTEXT_VALUE;
    cbData.cd = NULL;

    ret = OCDoResource(NULL,
		       method,
		       query,
		       dest,
		       (method == OC_REST_PUT || method == OC_REST_POST) ? set_put_payload() : NULL,
		       CT_DEFAULT,
		       qos,
		       &cbData,
		       options,
		       numOptions);

    if (ret != OC_STACK_OK)
    {
        OIC_LOG_V(ERROR, TAG, "OCDoResource returns error %d with method %d",
                 ret, method);
    }

    waiting = 1;
    return ret;
}

int retrieve_resource(OCQualityOfService qos)
{
  struct ResourceNode * iter;
  iter = resourceList;
  int i = 1;
  const char *adapters[5];
  adapters[0] = "IPv4";
  adapters[1] = "IPv6";
  adapters[2] = "BLE";
  adapters[3] = "BT";
  adapters[4] = "Invalid adapter";
  int adapter;
  printf("\nChoose a resource:\n");
  while(iter) {
    switch (iter->endpoint.adapter)
      {
      case OC_ADAPTER_IP:
	adapter = 0;
	break;
      case OC_ADAPTER_GATT_BTLE:
	adapter = 2;
	break;
      case OC_ADAPTER_RFCOMM_BTEDR:
	adapter = 3;
	break;
      default:
	adapter = 4;
	break;
      }
    printf("%d. %s : %-20s \t(%s)\n", i, iter->sid, iter->uri, adapters[adapter]);
    iter = iter->next;
    i++;
    }
  int max = i;
  printf("\nEnter choice: ");
  adapter = 0;
  scanf("%d", &adapter);
  if ( (adapter < 1) || (adapter > max) ) {
    printf("Invalid choice: %d\n", adapter);
    waiting = 0;
    return OC_STACK_OK;
  }
  i = 1;
  iter = resourceList;
  while(iter) {
    if (i == adapter)
      break;
    else {
      i++;
      iter = iter->next;
    }
  }

  OIC_LOG_V(INFO, TAG,"Executing RETRIEVE action on resource: %s", iter->uri);

  OCStackResult res = act_on_resource(iter->uri,
				      OC_REST_GET,
				      &iter->endpoint,
				      (qos == OC_HIGH_QOS) ? OC_HIGH_QOS : OC_LOW_QOS,
				      svc_get_response,
				      NULL,
				      0);
  return res;
}



/* **************************************************************** */
void *prompt_user()
{
  char action[1];
  struct timespec ts = { .tv_sec = 0,
			 .tv_nsec = 100000000L };

  while(!gQuitFlag) {
    if (waiting)
      nanosleep(&ts, NULL);
    else {
      printf("\nChoose an action:\n");
      printf("\t1) Platform discovery\n");
      printf("\t2) Device discovery\n");
      printf("\t3) Resource discovery\n");
      printf("\t4) Resource retrieval\n");
      printf("\tq) Quit\n");
      scanf("%s", action);
      switch(*action) {
      case '1':
	waiting = 1;
	discover_platform(OC_LOW_QOS);
	break;
      case '2':
	waiting = 1;
	discover_device(OC_LOW_QOS);
	break;
      case '3':
	waiting = 1;
	discover_resources(OC_LOW_QOS);
	break;
      case '4':
	waiting = 1;
	retrieve_resource(OC_LOW_QOS);
	break;
      case 'q':
	gQuitFlag = 1;
	fflush(stdout);
	break;
      default:
	printf("Unrecognized action: %s\n", action);
      }
    }
  }
}

/****************************************************************
 *  MAIN
 *  1. initialize rmgr (stack)
 *  2. register platform info
 *  3. register device info
 *  4. register service routine for default rsvp
 *  5. enter processing loop
 ****************************************************************/
int main(int argc, char* argv[])
{
    int opt = 0;

    /* while ((opt = getopt(argc, argv, "o:s:p:d:u:w:r:j:")) != -1) { */
    /*   switch(opt) { */
    /*   case 'o': */
    /* 	g_observe_notify_type = atoi(optarg); */
    /* 	break; */
    /*   default: */
    /* 	PrintUsage(); */
    /* 	return -1; */
    /*   } */
    /* } */

    /* if ((g_observe_notify_type != 0) && (g_observe_notify_type != 1)) { */
    /*     PrintUsage(); */
    /*     return -1; */
    /* } */

    printf("Client is starting...");

    OCStackResult op_result;

    /* 1. initialize */
    /* use default transport flags, so stack will pick a transport */
    op_result = OCInit1(OC_CLIENT, OC_DEFAULT_FLAGS, OC_DEFAULT_FLAGS);
    if (op_result != OC_STACK_OK) {
        printf("OCStack init error\n");
        return 0;
    }

    /* 2. register platform info */
    /* WARNING: platform registration only allowed for servers */
    /* To enable the following, use OC_SERVER or OC_CLIENT_SERVER in the call to OCInit1 above */
    /* op_result = OCSetPlatformInfo(platform_info); */
    /* if (op_result != OC_STACK_OK) { */
    /*     printf("Platform Registration failed!\n"); */
    /*     exit (EXIT_FAILURE); */
    /* } */

    /* 3. register default device info */
    /* WARNING: device registration only allowed for servers */
    /* OCResourcePayloadAddStringLL(&device_info.types, "oic.d.tv"); */
    /* op_result = OCSetDeviceInfo(device_info); */
    /* if (op_result != OC_STACK_OK) { */
    /*     printf("Device Registration failed!\n"); */
    /*     exit (EXIT_FAILURE); */
    /* } */

    // Initialize observations data structure for the resource
    /* for (uint8_t i = 0; i < SAMPLE_MAX_NUM_OBSERVATIONS; i++) */
    /* { */
    /*     interestedObservers[i].valid = false; */
    /* } */


    /*
     * Create a thread for generating changes that cause presence notifications
     * to be sent to clients
     */

    /* #ifdef WITH_PRESENCE */
    /* pthread_create(&threadId_presence, NULL, presenceNotificationGenerator, (void *)NULL); */
    /* #endif */

    // Break from loop with Ctrl-C
    printf("Entering client main loop...\n");

    /* DeletePlatformInfo(); */
    /* DeleteDeviceInfo(); */

    signal(SIGINT, handleSigInt);

    pthread_create (&ui_thread, NULL, &prompt_user, NULL);

    while (!gQuitFlag)
    {
        if (OCProcess() != OC_STACK_OK)
        {
            printf("OCStack process error\n");
            return 0;
        }
    }

    pthread_cancel(ui_thread);
    pthread_join(ui_thread, NULL);

    /* if (observeThreadStarted) */
    /* { */
    /*     pthread_cancel(threadId_observe); */
    /*     pthread_join(threadId_observe, NULL); */
    /* } */

    /* pthread_cancel(threadId_presence); */
    /* pthread_join(threadId_presence, NULL); */

    printf("Exiting client main loop...\n");

    if (OCStop() != OC_STACK_OK)
    {
        printf("OCStack stop error\n");
    }

    return 0;
}

