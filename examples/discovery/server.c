//******************************************************************
//
// Copyright 2016 NORC at the University of Chicago
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <getopt.h>
#include <signal.h>
#include <pthread.h>

#include "server.h"
#include "button.h"
#include "led.h"
#include "utils.h"

#define TAG "minserver"

pthread_t pt_work;

/* Platform Descriptor: OCPlatformInfo
 * This structure describes the platform properties. All non-Null properties will be
 * included in a platform discovery request. */
OCPlatformInfo platform_info =
  {
    .platformID			= "minPlatformID",
    .manufacturerName		= "minName",
    .manufacturerUrl		= "minManufacturerUrl",
    .modelNumber		= "minModelNumber",
    .dateOfManufacture		= "minDateOfManufacture",
    .platformVersion		= "minPlatformVersion",
    .operatingSystemVersion	= "minOS",
    .hardwareVersion		= "minHardwareVersion",
    .firmwareVersion		= "minFirmwareVersion",
    .supportUrl			= "minSupportUrl",
    .systemTime			= "2015-05-15T11.04"
  };

/* Device Descriptor: OCDeviceInfo
 * This structure is expected as input for device properties.
 * device name is mandatory and expected from the application.
 * device id of type UUID will be generated by the stack. */
OCDeviceInfo device_info =
  {
    .deviceName = "minDeviceName",
    /* OCStringLL *types; */
    .types = NULL,
    .specVersion = "minDeviceSpecVersion", /* device specification version */
    // .dataModelVersions = "minDeviceModelVersion"
    .dataModelVersions = NULL
  };

/* const char *deviceUUID = "myDeviceUUID"; */
/* const char *version = "myVersion"; */

OCEntityHandlerResult
default_request_dispatcher (OCEntityHandlerFlag flag,
			    OCEntityHandlerRequest *oic_request, /* just like HttpRequest */
			    char *uri,
			    void *cb /*callbackParam*/)
{
    UNUSED(flag);
    UNUSED(oic_request);
    UNUSED(uri);
    UNUSED(cb);
    OCEntityHandlerResult ehResult = OC_EH_OK;
    /* OCEntityHandlerResponse response; */
    return ehResult;
}

#define SAMPLE_MAX_NUM_OBSERVATIONS     8
#define SAMPLE_MAX_NUM_POST_INSTANCE  2

observers_t interestedObservers[SAMPLE_MAX_NUM_OBSERVATIONS];

pthread_t threadId_observe;
/* pthread_t threadId_presence; */

/* #ifdef WITH_PRESENCE */
/* #define numPresenceResources (2) */
/* #endif */

int gQuitFlag = 0;

/* SIGINT handler: set gQuitFlag to 1 for graceful termination */
void handleSigInt(int signum)
{
    if (signum == SIGINT)
    {
	/* if (OCStop() != OC_STACK_OK) { */
	/*     printf("OCStack process error\n"); */
	/* } else { */
	/*     printf("foo\n"); */
	/* } */
        gQuitFlag = 1;
    }
}

/* thread routine - service client requests */
void *troutine_work(void *arg)
{
    UNUSED(arg);
    printf("Entering server work thread...\n");

    while (!gQuitFlag) {
	if (OCProcess() != OC_STACK_OK) {
	    printf("OCStack process error\n");
	}
    }
    printf("Exiting server work thread...\n");
    /* we're the only thread left, pthread_exit(NULL) would kill us,
       but not the process. */
    exit(0);
}

/* FILE* server_fopen(const char *path, const char *mode) */
/* { */
/*     (void)path; */
/*     return fopen(CRED_FILE, mode); */
/* } */

static void PrintUsage()
{
    printf("Usage : ocserver -o <0|1>\n");
    printf("-o 0 : Notify all observers\n");
    printf("-o 1 : Notify list of observers\n");
}

/****************************************************************
 *  MAIN
 *  1. initialize rmgr (stack)
 *  2. register platform info
 *  3. register device info
 *  4. register service routine for default rsvp
 *  5. register Resource Service Provider for each resource
 *  6. spawn work thread
 *  7. exit main thread, leaving process (and work thread) running
 ****************************************************************/
int main(int argc, char* argv[])
{
    /* pthread_t pt_main = pthread_self(); */

    int opt = 0;

    while ((opt = getopt(argc, argv, "o:s:p:d:u:w:r:j:")) != -1) {
      switch(opt) {
      case 'o':
	g_observe_notify_type = atoi(optarg);
	break;
      default:
	PrintUsage();
	return -1;
      }
    }

    if ((g_observe_notify_type != 0) && (g_observe_notify_type != 1)) {
        PrintUsage();
        return -1;
    }

    OCStackResult op_result;

    /* /\* 0. if SECURED == 1 *\/ */
    /* // Initialize Persistent Storage for SVR database */
    /* OCPersistentStorage ps = { server_fopen, fread, fwrite, fclose, unlink }; */
    /* OCRegisterPersistentStorageHandler(&ps); */

    /* 1. initialize */
    op_result = OCInit(NULL, 0, OC_SERVER);
    if (op_result != OC_STACK_OK) {
        printf("OCStack init error\n");
        return 0;
    }

    /* 2. register platform info */
    op_result = OCSetPlatformInfo(platform_info);
    if (op_result != OC_STACK_OK) {
        printf("Platform Registration failed!\n");
        exit (EXIT_FAILURE);
    }

    /* 3. register default device info */
    OCResourcePayloadAddStringLL(&device_info.types, "oic.wk.d");
    op_result = OCSetDeviceInfo(device_info);
    if (op_result != OC_STACK_OK) {
        printf("Device Registration failed!\n");
        exit (EXIT_FAILURE);
    }

    /* 4. register service routine for default rsvp */
    op_result = OCSetDefaultDeviceEntityHandler(default_request_dispatcher, NULL);
    if (op_result != OC_STACK_OK) {
        printf("Default rsvp service routine registration failed!\n");
        exit (EXIT_FAILURE);
    }

    /* 5. register rsvps */
    struct rsvp_led my_led_rsvp = { .t     = RSC_T_LED,
				    .iface = RSC_IF_LED,
				    .uri   = RSC_URI_LED,
				    .props = { .state = 0, .power = 0 },
				    .dispatch_request = led_request_dispatcher };

    rmgr_register_led_rsvp (&my_led_rsvp);
    if (op_result != OC_STACK_OK) {
      printf("LED resource service provider registration failed!\n");
      exit (EXIT_FAILURE);
    }

    struct rsvp_button my_button_rsvp = { .t     = RSC_T_BUTTON,
					  .iface = RSC_IF_BUTTON,
					  .uri   = RSC_URI_BUTTON,
					  .props = { .state = 0 },
					  .dispatch_request = button_request_dispatcher };

    rmgr_register_button_rsvp (&my_button_rsvp);
    if (op_result != OC_STACK_OK) {
      printf("BUTTON resource service provider registration failed!\n");
      exit (EXIT_FAILURE);
    }

    /* register async quit signal handler */
    signal(SIGINT, handleSigInt);

    pthread_create (&pt_work, NULL, troutine_work, (void *)NULL);

    /* main thread has nothing to do. by calling pthread_exit it exits
       but the process continues, so any spawned threads do too. */
    pthread_exit(NULL);
}

